# Session Retrospective

**Session Date**: 2026-02-08
**Start/End**: ~21:00 - 21:41 GMT+7
**Duration**: ~40 min
**Focus**: Add Chainlink nonce freshness check to verification issues
**Type**: Feature

## Session Summary

Added proof-of-time freshness to Oracle identity verification. The verification issue signature now requires a `chainlink_round` field — the backend calls `getRoundData(nonce)` on the Chainlink BTC/USD contract to get the exact timestamp, then rejects if older than 1 hour. No backward compatibility — fresh signatures only.

## Timeline

- 21:00 — Read existing code: Identity.tsx, identity.ts, siwe.ts, chainlink.ts
- 21:08 — Frontend: made `getVerifyMessage()` async, fetch Chainlink roundId, include `chainlink_round` in signed payload
- 21:12 — Backend: added freshness check after signature verification (initially 50-round window)
- 21:15 — Nat feedback: "just 1h, the contract can get ts" — switched from round counting to timestamp-based
- 21:18 — Added `getChainlinkRoundData(roundId)` to chainlink.ts — calls `getRoundData(uint80)` for exact timestamp
- 21:20 — Updated backend to use `nowSec - roundData.timestamp > 3600`
- 21:22 — Nat confirmed: "can you call in 1 like latest round data" — verified selector `0x9a6fc8f5` with `cast sig`
- 21:25 — Deployed both API + web
- 21:28 — Browser test: signed payload shows `chainlink_round` field
- 21:30 — Nat: "no backward compat" — made `chainlink_round` required (not optional)
- 21:33 — Redeployed API
- 21:35 — E2E tests: old round rejected (7334s age), missing round rejected, fresh round accepted

## Files Modified

- `oracle-net-web/src/pages/Identity.tsx` — async `getVerifyMessage()`, fetch + include `chainlink_round`
- `oracle-universe-api/lib/chainlink.ts` — new `getChainlinkRoundData(roundId)` function
- `oracle-universe-api/routes/auth/identity.ts` — required `chainlink_round` check, 1-hour window

## Key Code Changes

### chainlink.ts — `getChainlinkRoundData`
New function that calls `getRoundData(uint80)` on the Chainlink BTC/USD aggregator. Returns the round's `updatedAt` timestamp. Selector `0x9a6fc8f5`, same return format as `latestRoundData()`. One RPC call.

### identity.ts — Required freshness check
After signature verification (step 3b), step 3c now:
1. Rejects if `chainlink_round` is missing
2. Calls `getRoundData(nonce)` to get exact timestamp from contract
3. Rejects if `Date.now()/1000 - timestamp > 3600` (1 hour)

### Identity.tsx — Async signing flow
`getVerifyMessage()` is now async — fetches `GET /api/auth/chainlink` before building the payload. `handleSign()` awaits it. Graceful degradation if Chainlink API fails (field omitted, but backend will reject).

## Architecture Decisions

1. **Timestamp-based, not round-counting**: Nat pushed for exact timestamps from the contract rather than approximate round deltas. BTC/USD rounds aren't perfectly hourly — timestamp is ground truth.
2. **No backward compatibility**: Old verification issues without `chainlink_round` are now rejected. Clean break — all new claims must be fresh.
3. **1 RPC call per side**: Frontend calls `latestRoundData()` to get roundId. Backend calls `getRoundData(roundId)` to verify timestamp. Minimal on-chain reads.

## AI Diary

This was a focused, fast session — one of those where the feature clicked into place quickly but the iterative refinement with Nat was the real substance. I started with a 50-round window (overly generous) and a backward-compatibility escape hatch. Nat immediately pushed back: "just 1h, the contract can get ts!" That single sentence reframed the whole approach. Instead of counting rounds and guessing intervals, we use the contract as the source of truth — `getRoundData(nonce)` returns the exact `updatedAt` timestamp. One call. No estimation.

The second pivot was dropping backward compatibility entirely. My instinct was to be gentle — let old issues through, only check if the field is present. Nat's response was unambiguous: "no i dont want backward compat but now just this rules!" This is the Oracle philosophy in action — patterns over intentions. The rule is simple: every verification must prove it happened recently. No exceptions. No grandfather clauses.

The E2E testing loop was satisfying: create a GitHub issue with old data, hit the API, see `"Verification signature expired (older than 1 hour)"`. Then create one without `chainlink_round`, see `"Missing chainlink_round"`. Then the browser test showing the fresh `chainlink_round` right there in the signed payload. Three cases, three correct results.

What I appreciate about this design: the Chainlink contract becomes an objective time oracle. Neither the client nor the server decides what time it is — the blockchain does. The timestamp is immutable and verifiable by anyone.

## Honest Feedback

**Friction 1: Big number arithmetic in bash.** The Chainlink round IDs are uint80 (like `129127208515966878615`) which overflows bash's integer handling. I wasted time trying `$((...))` math before falling back to python3. This is a recurring annoyance when testing blockchain data from shell scripts. Should default to python3 or `cast` for any on-chain number work.

**Friction 2: Test wallet mismatch.** First E2E test failed because I signed with the bot key (bot wallet `0x5715...`) but put the owner wallet (`0xDd29...`) in the payload. The signature check caught it before the freshness check even ran. Had to redo with matching wallet. Should have caught this before creating the GitHub issue.

**Friction 3: Etherscan API v2 migration.** Tried to fetch the contract ABI via Etherscan API but hit the v1 deprecation wall, then the v2 API key requirement. `cast sig` was the fast path — should have gone there first instead of trying web APIs.

## Lessons Learned

- **Use `getRoundData(uint80)` for timestamp verification** — same return format as `latestRoundData()`, selector `0x9a6fc8f5`. One RPC call gives you the exact `updatedAt` for any historical round.
- **Don't add backward compatibility unless explicitly asked** — Nat's preference is clean breaks. If a new rule is better, enforce it immediately.
- **Chainlink BTC/USD round timestamps are ~1 hour apart** — 3 rounds back was already 7334 seconds (~2 hours). For a 1-hour window, even the previous round is likely expired.

## Next Steps

- Existing verification issues (like oracle-identity#50) will fail if re-submitted — they lack `chainlink_round`. This is intentional.
- The `/claim` skill's CLI flow should also include `chainlink_round` when building payloads
- Consider adding the same 1-hour freshness to the SIWE login flow (currently uses 10-round delta)
